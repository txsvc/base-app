# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/rly/all/rly.rbi
#
# rly-0.2.3

module Rly
end
class Rly::LexToken
  def initialize(type, value, lexer, pos = nil, lineno = nil, filename = nil); end
  def inspect; end
  def lexer; end
  def location_info; end
  def location_info=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
class Rly::LexError < Exception
end
class Rly::Lex
  def build_token(type, value); end
  def ignore_symbol; end
  def initialize(input = nil); end
  def input(input); end
  def inspect; end
  def lineno; end
  def lineno=(arg0); end
  def next; end
  def pos; end
  def pos=(arg0); end
  def self.callables; end
  def self.error_hander; end
  def self.ignore(ign); end
  def self.ignores_list; end
  def self.literals(lit); end
  def self.literals_list; end
  def self.metatokens(*args); end
  def self.metatokens_list; end
  def self.on_error(&block); end
  def self.terminals; end
  def self.token(*args, &block); end
  def self.token_regexps; end
  def self.tokens; end
end
class Rly::FileLex < Rly::Lex
  def build_token(type, value); end
  def initialize(fn = nil); end
  def next; end
  def pop_file; end
  def push_file(fn); end
end
class Rly::Production
  def block; end
  def index; end
  def initialize(index, name, prod, precedence = nil, block = nil); end
  def inspect; end
  def length; end
  def line; end
  def lr0_added; end
  def lr0_added=(arg0); end
  def lr_items; end
  def lr_items=(arg0); end
  def lr_next; end
  def lr_next=(arg0); end
  def name; end
  def precedence; end
  def prod; end
  def reduced; end
  def reduced=(arg0); end
  def to_s; end
  def usyms; end
end
class Rly::LRItem
  def index; end
  def initialize(p, n); end
  def inspect; end
  def length; end
  def lookaheads; end
  def lr_after; end
  def lr_after=(arg0); end
  def lr_before; end
  def lr_before=(arg0); end
  def lr_index; end
  def lr_next; end
  def lr_next=(arg0); end
  def name; end
  def prod; end
  def to_s; end
  def usyms; end
end
class Rly::Grammar
  def _first(beta); end
  def add_production(name, symbols, enforced_prec = nil, &block); end
  def build_lritems; end
  def compute_first; end
  def compute_follow(start = nil); end
  def initialize(terminals); end
  def nonterminals; end
  def prec_for_rightmost_terminal(symbols); end
  def precedence; end
  def prodnames; end
  def productions; end
  def set_precedence(term, assoc, level); end
  def set_start(symbol = nil); end
  def start; end
  def terminals; end
end
class Rly::YaccProduction
  def initialize(slice, stack = nil); end
  def lexer; end
  def lexer=(arg0); end
  def parser; end
  def parser=(arg0); end
  def slice; end
  def slice=(arg0); end
  def stack; end
  def stack=(arg0); end
end
class Rly::YaccSymbol
  def endlexpos; end
  def endlexpos=(arg0); end
  def endlineno; end
  def endlineno=(arg0); end
  def inspect; end
  def lexpos; end
  def lexpos=(arg0); end
  def lineno; end
  def lineno=(arg0); end
  def to_s; end
  def type; end
  def type=(arg0); end
  def value; end
  def value=(arg0); end
end
class Rly::LRTable
  def add_lalr_lookaheads(c); end
  def add_lookaheads(lookbacks, followset); end
  def compute_follow_sets(ntrans, readsets, inclsets); end
  def compute_lookback_includes(c, trans, nullable); end
  def compute_nullable_nonterminals; end
  def compute_read_sets(c, ntrans, nullable); end
  def digraph(x, r, fp); end
  def dr_relation(c, trans, nullable); end
  def find_nonterminal_transitions(c); end
  def initialize(grammar, method = nil); end
  def lr0_closure(i); end
  def lr0_goto(i, x); end
  def lr0_items; end
  def lr_action; end
  def lr_goto; end
  def lr_productions; end
  def parse_table(log = nil); end
  def reads_relation(c, trans, empty); end
  def traverse(xx, n, stack, f, x, r, fp); end
end
class Rly::PlyDump
  def backlog; end
  def debug(*args); end
  def info(*args); end
  def initialize(grammar); end
  def self.stub; end
  def to_s; end
end
class Rly::PlyDump::TinyContext
  def get_binding; end
  def initialize(ctx); end
  def method_missing(m); end
end
class Rly::YaccError < RuntimeError
end
class Rly::Yacc
  def grammar; end
  def initialize(lex = nil); end
  def inspect; end
  def lex; end
  def lr_table; end
  def parse(input = nil, trace = nil); end
  def self.error_count; end
  def self.error_handler; end
  def self.error_handler=(arg0); end
  def self.grammar; end
  def self.grammar=(arg0); end
  def self.lexer(&block); end
  def self.lexer_class; end
  def self.lexer_class=(arg0); end
  def self.on_error(lambda); end
  def self.parsed_rules; end
  def self.prec_rules; end
  def self.prec_rules=(arg0); end
  def self.precedence(*prec); end
  def self.rule(desc, &block); end
  def self.rules; end
  def self.rules=(arg0); end
  def self.store_grammar(fn); end
  def self.store_grammar_def; end
  def self.store_grammar_def=(arg0); end
end
class Rly::RuleParser < Rly::Yacc
  def grammar; end
  def self.lexer_class; end
end

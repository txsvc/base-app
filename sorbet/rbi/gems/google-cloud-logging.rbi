# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/google-cloud-logging/all/google-cloud-logging.rbi
#
# google-cloud-logging-1.10.9

module Google
end
module Google::Cloud
  def logging(scope: nil, timeout: nil, client_config: nil); end
  def self.logging(project_id = nil, credentials = nil, scope: nil, timeout: nil, client_config: nil); end
end
module Google::Cloud::Logging
  def self.configure; end
  def self.default_credentials(scope: nil); end
  def self.default_project_id; end
  def self.new(project_id: nil, credentials: nil, scope: nil, timeout: nil, client_config: nil, endpoint: nil, project: nil, keyfile: nil); end
end
module Google::Logging
end
module Google::Logging::V2
end
class Google::Logging::V2::LogBucket
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::LogSink
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
module Google::Logging::V2::LogSink::VersionFormat
  def self.descriptor; end
  def self.lookup(arg0); end
  def self.resolve(arg0); end
end
class Google::Logging::V2::BigQueryOptions
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListBucketsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListBucketsResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::UpdateBucketRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::GetBucketRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListSinksRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListSinksResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::GetSinkRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::CreateSinkRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::UpdateSinkRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::DeleteSinkRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::LogExclusion
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListExclusionsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListExclusionsResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::GetExclusionRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::CreateExclusionRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::UpdateExclusionRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::DeleteExclusionRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::GetCmekSettingsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::UpdateCmekSettingsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::CmekSettings
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
module Google::Logging::V2::LifecycleState
  def self.descriptor; end
  def self.lookup(arg0); end
  def self.resolve(arg0); end
end
module Google::Cloud::Logging::V2
end
class Google::Cloud::Logging::V2::Credentials < Google::Auth::Credentials
end
class Google::Cloud::Logging::V2::ConfigServiceV2Client
  def config_service_v2_stub; end
  def create_exclusion(parent, exclusion, options: nil, &block); end
  def create_sink(parent, sink, unique_writer_identity: nil, options: nil, &block); end
  def delete_exclusion(name, options: nil, &block); end
  def delete_sink(sink_name, options: nil, &block); end
  def get_bucket(name, options: nil, &block); end
  def get_cmek_settings(name, options: nil, &block); end
  def get_exclusion(name, options: nil, &block); end
  def get_sink(sink_name, options: nil, &block); end
  def initialize(credentials: nil, scopes: nil, client_config: nil, timeout: nil, metadata: nil, service_address: nil, service_port: nil, exception_transformer: nil, lib_name: nil, lib_version: nil); end
  def list_buckets(parent, page_size: nil, options: nil, &block); end
  def list_exclusions(parent, page_size: nil, options: nil, &block); end
  def list_sinks(parent, page_size: nil, options: nil, &block); end
  def self.billing_account_location_path(billing_account, location); end
  def self.billing_account_path(billing_account); end
  def self.cmek_settings_path(project); end
  def self.folder_location_path(folder, location); end
  def self.folder_path(folder); end
  def self.location_path(project, location); end
  def self.log_bucket_path(project, location, bucket); end
  def self.log_exclusion_path(project, exclusion); end
  def self.log_sink_path(project, sink); end
  def self.organization_location_path(organization, location); end
  def self.organization_path(organization); end
  def self.project_path(project); end
  def update_bucket(name, bucket, update_mask, options: nil, &block); end
  def update_cmek_settings(name, cmek_settings, update_mask: nil, options: nil, &block); end
  def update_exclusion(name, exclusion, update_mask, options: nil, &block); end
  def update_sink(sink_name, sink, unique_writer_identity: nil, update_mask: nil, options: nil, &block); end
end
class Google::Logging::V2::LogEntry
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::LogEntryOperation
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::LogEntrySourceLocation
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::DeleteLogRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::WriteLogEntriesRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::WriteLogEntriesResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::WriteLogEntriesPartialErrors
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListLogEntriesRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListLogEntriesResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListMonitoredResourceDescriptorsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListMonitoredResourceDescriptorsResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListLogsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListLogsResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Cloud::Logging::V2::LoggingServiceV2Client
  def delete_log(log_name, options: nil, &block); end
  def initialize(credentials: nil, scopes: nil, client_config: nil, timeout: nil, metadata: nil, service_address: nil, service_port: nil, exception_transformer: nil, lib_name: nil, lib_version: nil); end
  def list_log_entries(resource_names, filter: nil, order_by: nil, page_size: nil, options: nil, &block); end
  def list_logs(parent, page_size: nil, options: nil, &block); end
  def list_monitored_resource_descriptors(page_size: nil, options: nil, &block); end
  def logging_service_v2_stub; end
  def self.billing_account_path(billing_account); end
  def self.folder_path(folder); end
  def self.log_path(project, log); end
  def self.organization_path(organization); end
  def self.project_path(project); end
  def write_log_entries(entries, log_name: nil, resource: nil, labels: nil, partial_success: nil, dry_run: nil, options: nil, &block); end
end
class Google::Logging::V2::LogMetric
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
module Google::Logging::V2::LogMetric::ApiVersion
  def self.descriptor; end
  def self.lookup(arg0); end
  def self.resolve(arg0); end
end
class Google::Logging::V2::ListLogMetricsRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::ListLogMetricsResponse
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::GetLogMetricRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::CreateLogMetricRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::UpdateLogMetricRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Logging::V2::DeleteLogMetricRequest
  def ==(arg0); end
  def [](arg0); end
  def []=(arg0, arg1); end
  def clone; end
  def dup; end
  def eql?(arg0); end
  def hash; end
  def initialize(*arg0); end
  def inspect; end
  def method_missing(*arg0); end
  def respond_to_missing?(*arg0); end
  def self.decode(arg0); end
  def self.decode_json(*arg0); end
  def self.descriptor; end
  def self.encode(arg0); end
  def self.encode_json(*arg0); end
  def to_h; end
  def to_s; end
end
class Google::Cloud::Logging::V2::MetricsServiceV2Client
  def create_log_metric(parent, metric, options: nil, &block); end
  def delete_log_metric(metric_name, options: nil, &block); end
  def get_log_metric(metric_name, options: nil, &block); end
  def initialize(credentials: nil, scopes: nil, client_config: nil, timeout: nil, metadata: nil, service_address: nil, service_port: nil, exception_transformer: nil, lib_name: nil, lib_version: nil); end
  def list_log_metrics(parent, page_size: nil, options: nil, &block); end
  def metrics_service_v2_stub; end
  def self.log_metric_path(project, metric); end
  def self.project_path(project); end
  def update_log_metric(metric_name, metric, options: nil, &block); end
end
class Google::Cloud::Logging::Service
  def client_config; end
  def client_config=(arg0); end
  def create_metric(name, filter, description); end
  def create_sink(name, destination, filter, unique_writer_identity: nil); end
  def credentials; end
  def credentials=(arg0); end
  def default_headers; end
  def default_options; end
  def delete_log(name); end
  def delete_metric(name); end
  def delete_sink(name); end
  def execute; end
  def get_metric(name); end
  def get_sink(name); end
  def host; end
  def host=(arg0); end
  def initialize(project, credentials, timeout: nil, client_config: nil, host: nil); end
  def inspect; end
  def list_entries(resources: nil, filter: nil, order: nil, token: nil, max: nil, projects: nil); end
  def list_logs(resource: nil, token: nil, max: nil); end
  def list_metrics(token: nil, max: nil); end
  def list_resource_descriptors(token: nil, max: nil); end
  def list_sinks(token: nil, max: nil); end
  def log_path(log_name); end
  def logging; end
  def metric_path(metric_name); end
  def metrics; end
  def mocked_logging; end
  def mocked_logging=(arg0); end
  def mocked_metrics; end
  def mocked_metrics=(arg0); end
  def mocked_sinks; end
  def mocked_sinks=(arg0); end
  def project; end
  def project=(arg0); end
  def project_path; end
  def service_address; end
  def service_port; end
  def sink_path(sink_name); end
  def sinks; end
  def time_to_timestamp(time); end
  def timeout; end
  def timeout=(arg0); end
  def timestamp_to_time(timestamp); end
  def update_metric(name, description, filter); end
  def update_sink(name, destination, filter, unique_writer_identity: nil); end
  def write_entries(entries, log_name: nil, resource: nil, labels: nil, partial_success: nil); end
end
class Google::Cloud::Logging::Credentials < Google::Cloud::Logging::V2::Credentials
end
class Google::Cloud::Logging::Log
end
class Google::Cloud::Logging::Log::List < Anonymous_Delegator_68
  def all(request_limit: nil); end
  def ensure_service!; end
  def initialize(arr = nil); end
  def next; end
  def next?; end
  def self.from_grpc(grpc_list, service, resource: nil, max: nil); end
  def token; end
  def token=(arg0); end
end
module Google::Cloud::Logging::Convert
  def self.array_to_list(array); end
  def self.hash_to_struct(hash); end
  def self.map_to_hash(map); end
  def self.object_to_value(obj); end
end
class Google::Cloud::Logging::Resource
  def empty?; end
  def initialize; end
  def labels; end
  def labels=(arg0); end
  def self.from_grpc(grpc); end
  def to_grpc; end
  def type; end
  def type=(arg0); end
end
class Google::Cloud::Logging::Entry
  def alert!; end
  def alert?; end
  def append_payload(grpc); end
  def critical!; end
  def critical?; end
  def debug!; end
  def debug?; end
  def default!; end
  def default?; end
  def emergency!; end
  def emergency?; end
  def empty?; end
  def error!; end
  def error?; end
  def http_request; end
  def info!; end
  def info?; end
  def initialize; end
  def insert_id; end
  def insert_id=(arg0); end
  def labels; end
  def labels=(arg0); end
  def labels_grpc; end
  def log_name; end
  def log_name=(arg0); end
  def notice!; end
  def notice?; end
  def operation; end
  def payload; end
  def payload=(arg0); end
  def resource; end
  def resource=(arg0); end
  def self.extract_payload(grpc); end
  def self.extract_timestamp(grpc); end
  def self.from_grpc(grpc); end
  def self.insert_id; end
  def severity; end
  def severity=(arg0); end
  def source_location; end
  def timestamp; end
  def timestamp=(arg0); end
  def timestamp_grpc; end
  def to_grpc; end
  def trace; end
  def trace=(arg0); end
  def trace_sampled; end
  def trace_sampled=(arg0); end
  def warning!; end
  def warning?; end
end
class Google::Cloud::Logging::Entry::HttpRequest
  def cache_hit; end
  def cache_hit=(arg0); end
  def empty?; end
  def initialize; end
  def method(*args); end
  def method=(new_request_method); end
  def referer; end
  def referer=(arg0); end
  def remote_ip; end
  def remote_ip=(arg0); end
  def request_method; end
  def request_method=(arg0); end
  def response_size; end
  def response_size=(arg0); end
  def self.from_grpc(grpc); end
  def size; end
  def size=(arg0); end
  def status; end
  def status=(arg0); end
  def to_grpc; end
  def url; end
  def url=(arg0); end
  def user_agent; end
  def user_agent=(arg0); end
  def validated; end
  def validated=(arg0); end
end
class Google::Cloud::Logging::Entry::Operation
  def empty?; end
  def first; end
  def first=(arg0); end
  def id; end
  def id=(arg0); end
  def initialize; end
  def last; end
  def last=(arg0); end
  def producer; end
  def producer=(arg0); end
  def self.from_grpc(grpc); end
  def to_grpc; end
end
class Google::Cloud::Logging::Entry::SourceLocation
  def empty?; end
  def file; end
  def file=(arg0); end
  def function; end
  def function=(arg0); end
  def initialize; end
  def line; end
  def line=(arg0); end
  def self.from_grpc(grpc); end
  def to_grpc; end
end
class Google::Cloud::Logging::Entry::List < Anonymous_Delegator_69
  def all(request_limit: nil); end
  def ensure_service!; end
  def initialize(arr = nil); end
  def next; end
  def next?; end
  def self.from_grpc(grpc_list, service, resources: nil, filter: nil, order: nil, max: nil, projects: nil); end
  def token; end
  def token=(arg0); end
end
class Google::Cloud::Logging::ResourceDescriptor
  def description; end
  def initialize; end
  def labels; end
  def name; end
  def self.from_grpc(grpc); end
  def type; end
end
class Google::Cloud::Logging::ResourceDescriptor::List < Anonymous_Delegator_70
  def all(request_limit: nil); end
  def ensure_service!; end
  def initialize(arr = nil); end
  def next; end
  def next?; end
  def self.from_grpc(grpc_list, service, max = nil); end
  def token; end
  def token=(arg0); end
end
class Google::Cloud::Logging::ResourceDescriptor::LabelDescriptor
  def description; end
  def key; end
  def self.from_grpc(grpc); end
  def type; end
end
class Google::Cloud::Logging::Sink
  def delete; end
  def destination; end
  def destination=(destination); end
  def end_at; end
  def end_at=(_new_end_at); end
  def end_time; end
  def end_time=(_new_end_at); end
  def ensure_service!; end
  def filter; end
  def filter=(filter); end
  def grpc; end
  def grpc=(arg0); end
  def initialize; end
  def name; end
  def refresh!; end
  def reload!; end
  def save(unique_writer_identity: nil); end
  def self.from_grpc(grpc, service); end
  def service; end
  def service=(arg0); end
  def start_at; end
  def start_at=(_new_start_at); end
  def start_time; end
  def start_time=(_new_start_at); end
  def time_to_timestamp(time); end
  def timestamp_to_time(timestamp); end
  def unspecified?; end
  def v1?; end
  def v2?; end
  def version; end
  def version=(_version); end
  def writer_identity; end
end
class Google::Cloud::Logging::Sink::List < Anonymous_Delegator_71
  def all(request_limit: nil); end
  def ensure_service!; end
  def initialize(arr = nil); end
  def next; end
  def next?; end
  def self.from_grpc(grpc_list, service, max = nil); end
  def token; end
  def token=(arg0); end
end
class Google::Cloud::Logging::Metric
  def delete; end
  def description; end
  def description=(description); end
  def ensure_service!; end
  def filter; end
  def filter=(filter); end
  def grpc; end
  def grpc=(arg0); end
  def initialize; end
  def name; end
  def refresh!; end
  def reload!; end
  def save; end
  def self.from_grpc(grpc, service); end
  def service; end
  def service=(arg0); end
end
class Google::Cloud::Logging::Metric::List < Anonymous_Delegator_72
  def all(request_limit: nil); end
  def ensure_service!; end
  def initialize(arr = nil); end
  def next; end
  def next?; end
  def self.from_grpc(grpc_list, service, max = nil); end
  def token; end
  def token=(arg0); end
end
class Google::Cloud::Logging::AsyncWriterError < Google::Cloud::Error
  def entries; end
  def initialize(message, entries = nil); end
end
class Google::Cloud::Logging::AsyncWriteEntriesError < Google::Cloud::Error
  def entries; end
  def initialize(message, entries = nil); end
end
class Google::Cloud::Logging::AsyncWriter
  def async_stop!(timeout = nil, force: nil); end
  def default_error_callbacks; end
  def error!(error); end
  def flush; end
  def initialize(logging, max_count: nil, max_bytes: nil, max_queue: nil, interval: nil, threads: nil, partial_success: nil); end
  def interval; end
  def last_error; end
  def last_exception; end
  def logger(log_name, resource, labels = nil); end
  def logging; end
  def max_bytes; end
  def max_count; end
  def max_queue; end
  def on_error(&block); end
  def partial_success; end
  def publish_batch!; end
  def publish_batch_async(batch); end
  def run_background; end
  def started?; end
  def stop!(timeout = nil, force: nil); end
  def stop; end
  def stopped?; end
  def threads; end
  def wait!(timeout = nil); end
  def write_entries(entries, log_name: nil, resource: nil, labels: nil); end
  def write_entries_with(entries); end
  include MonitorMixin
end
class Google::Cloud::Logging::AsyncWriter::Batch
  def add(entry, addl_bytes: nil); end
  def addl_bytes_for(entry); end
  def created_at; end
  def entries; end
  def initialize(writer); end
  def publish_at; end
  def publish_wait; end
  def ready?; end
  def try_add(entry); end
end
class Google::Cloud::Logging::Logger
  def <<(msg); end
  def add(severity, message = nil, progname = nil); end
  def add_request_info(info: nil, env: nil, trace_id: nil, log_name: nil, trace_sampled: nil); end
  def add_trace_id(trace_id); end
  def close; end
  def compute_label_value(request_env, value_or_proc); end
  def compute_labels(request_env); end
  def current_thread_id; end
  def datetime_format; end
  def datetime_format=(arg0); end
  def debug(message = nil, &block); end
  def debug?; end
  def delete_request_info; end
  def delete_trace_id; end
  def derive_severity(severity); end
  def entry_labels(info); end
  def error(message = nil, &block); end
  def error?; end
  def fatal(message = nil, &block); end
  def fatal?; end
  def flush; end
  def formatter; end
  def formatter=(arg0); end
  def gcloud_severity(severity_int); end
  def info(message = nil, &block); end
  def info?; end
  def initialize(writer, log_name, resource, labels = nil); end
  def labels; end
  def level; end
  def level=(severity); end
  def local_level; end
  def local_level=(severity); end
  def log(severity, message = nil, progname = nil); end
  def log_name; end
  def progname; end
  def progname=(name); end
  def project; end
  def project=(arg0); end
  def reopen(_logdev = nil); end
  def request_info; end
  def resource; end
  def sev_threshold; end
  def sev_threshold=(severity); end
  def silence(temp_level = nil); end
  def silencer; end
  def silencer=(arg0); end
  def trace_ids; end
  def unknown(message = nil, &block); end
  def unknown?; end
  def warn(message = nil, &block); end
  def warn?; end
  def write_entry(severity, message); end
  def writer; end
end
class Google::Cloud::Logging::Logger::RequestInfo < Struct
  def env; end
  def env=(_); end
  def log_name; end
  def log_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def trace_id; end
  def trace_id=(_); end
  def trace_sampled; end
  def trace_sampled=(_); end
end
class Google::Cloud::Logging::Middleware
  def call(env); end
  def configuration; end
  def get_log_name(env); end
  def get_trace_id(env); end
  def init_default_config; end
  def initialize(app, logger: nil, on_init: nil, **kwargs); end
  def load_config(**kwargs); end
  def logger; end
  def self.build_monitored_resource(type = nil, labels = nil); end
  def self.default_monitored_resource; end
  def self.logger; end
  def self.logger=(arg0); end
end
class Google::Cloud::Logging::Project
  def async_writer(max_batch_count: nil, max_batch_bytes: nil, max_queue_size: nil, interval: nil, threads: nil, partial_success: nil); end
  def create_metric(name, filter, description: nil); end
  def create_sink(name, destination, filter: nil, unique_writer_identity: nil, start_at: nil, end_at: nil, version: nil); end
  def delete_log(name); end
  def ensure_service!; end
  def entries(resources: nil, filter: nil, order: nil, token: nil, max: nil, projects: nil); end
  def entry(log_name: nil, resource: nil, timestamp: nil, severity: nil, insert_id: nil, labels: nil, payload: nil); end
  def find_entries(resources: nil, filter: nil, order: nil, token: nil, max: nil, projects: nil); end
  def find_log_names(resource: nil, token: nil, max: nil); end
  def find_logs(resource: nil, token: nil, max: nil); end
  def find_metric(name); end
  def find_metrics(token: nil, max: nil); end
  def find_resource_descriptors(token: nil, max: nil); end
  def find_sink(sink_name); end
  def find_sinks(token: nil, max: nil); end
  def get_metric(name); end
  def get_sink(sink_name); end
  def initialize(service); end
  def log_names(resource: nil, token: nil, max: nil); end
  def logger(log_name, resource, labels = nil); end
  def logs(resource: nil, token: nil, max: nil); end
  def metric(name); end
  def metrics(token: nil, max: nil); end
  def new_entry(log_name: nil, resource: nil, timestamp: nil, severity: nil, insert_id: nil, labels: nil, payload: nil); end
  def new_metric(name, filter, description: nil); end
  def new_resource(type, labels = nil); end
  def new_sink(name, destination, filter: nil, unique_writer_identity: nil, start_at: nil, end_at: nil, version: nil); end
  def project; end
  def project_id; end
  def resource(type, labels = nil); end
  def resource_descriptors(token: nil, max: nil); end
  def service; end
  def service=(arg0); end
  def shared_async_writer; end
  def sink(sink_name); end
  def sinks(token: nil, max: nil); end
  def write_entries(entries, log_name: nil, resource: nil, labels: nil, partial_success: nil); end
end
class Google::Cloud::Logging::Railtie < Rails::Railtie
  def self.consolidate_rails_config(config); end
  def self.init_default_config; end
  def self.init_middleware(app); end
  def self.merge_rails_config(rails_config); end
  def self.set_default_logger; end
  def self.valid_credentials?(project_id, credentials); end
end

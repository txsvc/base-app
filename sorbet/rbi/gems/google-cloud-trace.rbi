# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/google-cloud-trace/all/google-cloud-trace.rbi
#
# google-cloud-trace-0.40.0

module Google
end
module Google::Cloud
  def self.trace(project_id = nil, credentials = nil, scope: nil, timeout: nil); end
  def trace(scope: nil, timeout: nil); end
end
module Google::Cloud::Trace
  def self.configure; end
  def self.default_credentials(scope: nil); end
  def self.default_project_id; end
  def self.get; end
  def self.in_span(name, kind: nil, labels: nil); end
  def self.new(project_id: nil, credentials: nil, scope: nil, timeout: nil, endpoint: nil, project: nil, keyfile: nil); end
  def self.resolve_credentials(credentials, scope); end
  def self.set(trace); end
end
class Google::Cloud::Trace::Credentials < Google::Cloud::Trace::V1::TraceService::Credentials
end
module Google::Cloud::Trace::LabelKey
  def self.set_stack_trace(labels, stack_frames: nil, skip_frames: nil, truncate_stack: nil, filter_stack: nil); end
end
class Google::Cloud::Trace::AsyncReporterError < Google::Cloud::Error
  def initialize(message, traces = nil); end
  def traces; end
end
class Google::Cloud::Trace::AsyncPatchTracesError < Google::Cloud::Error
  def initialize(message, traces = nil); end
  def traces; end
end
class Google::Cloud::Trace::AsyncReporter
  def default_error_callbacks; end
  def error!(error); end
  def flush!; end
  def init_resources!; end
  def initialize(service, max_count: nil, max_bytes: nil, max_queue: nil, interval: nil, threads: nil); end
  def interval; end
  def max_bytes; end
  def max_count; end
  def max_queue; end
  def on_error(&block); end
  def patch_batch!; end
  def patch_traces(traces); end
  def patch_traces_async(batch); end
  def patch_traces_with(traces); end
  def project; end
  def raise_stopped_error(traces); end
  def run_background; end
  def service; end
  def started?; end
  def stop!(timeout = nil); end
  def stop; end
  def stopped?; end
  def threads; end
  def wait!(timeout = nil); end
  include MonitorMixin
end
class Google::Cloud::Trace::AsyncReporter::Batch
  def add(trace, addl_bytes: nil); end
  def addl_bytes_for(trace); end
  def created_at; end
  def initialize(reporter); end
  def publish_at; end
  def publish_wait; end
  def ready?; end
  def traces; end
  def try_add(trace); end
end
class Google::Cloud::Trace::Middleware
  def call(env); end
  def configuration; end
  def configure_result(span, result); end
  def configure_span(span, env); end
  def create_trace(env); end
  def error_callback; end
  def get_host(env); end
  def get_path(env); end
  def get_trace_context(env); end
  def get_url(env); end
  def handle_error(error, logger: nil); end
  def init_default_config; end
  def initialize(app, service: nil, **kwargs); end
  def load_config(**kwargs); end
  def send_trace(trace, env); end
  def set_basic_labels(labels, env); end
  def set_extended_labels(labels, capture_stack); end
  def set_label(labels, key, value); end
end
module Google::Cloud::Trace::Notifications
  def self.handle_notification_event(event, maxlen, label_namespace, capture_stack); end
  def self.instrument(type, max_length: nil, label_namespace: nil, capture_stack: nil); end
  def self.payload_to_labels(event, maxlen, label_namespace); end
end
class Google::Cloud::Trace::Project
  def ensure_service!; end
  def get_trace(trace_id); end
  def initialize(service); end
  def list_traces(start_time, end_time, filter: nil, order_by: nil, view: nil, page_size: nil, page_token: nil); end
  def new_trace(trace_context: nil); end
  def patch_traces(traces); end
  def project; end
  def project_id; end
  def service; end
  def service=(arg0); end
end
class Google::Cloud::Trace::ResultSet
  def each(&block); end
  def end_time; end
  def filter; end
  def initialize(service, project, results, next_page_token, start_time, end_time, filter: nil, order_by: nil, view: nil, page_size: nil, page_token: nil); end
  def next_page; end
  def next_page_token; end
  def order_by; end
  def page_size; end
  def page_token; end
  def project; end
  def results_pending?; end
  def self.from_gapic_page(service, project_id, page, start_time, end_time, filter: nil, order_by: nil, view: nil, page_size: nil, page_token: nil); end
  def service; end
  def size; end
  def start_time; end
  def view; end
  include Enumerable
end
class Google::Cloud::Trace::Service
  def credentials; end
  def credentials=(arg0); end
  def get_trace(trace_id); end
  def host; end
  def host=(arg0); end
  def initialize(project, credentials, timeout: nil, host: nil); end
  def inspect; end
  def list_traces(project_id, start_time, end_time, filter: nil, order_by: nil, view: nil, page_size: nil, page_token: nil); end
  def lowlevel_client; end
  def mocked_lowlevel_client; end
  def mocked_lowlevel_client=(arg0); end
  def patch_traces(traces); end
  def project; end
  def project=(arg0); end
  def timeout; end
  def timeout=(arg0); end
end
class Google::Cloud::Trace::Span
  def ==(other); end
  def add_child(child); end
  def children; end
  def create_span(name, span_id: nil, kind: nil, start_time: nil, end_time: nil, labels: nil); end
  def delete; end
  def end_time; end
  def end_time=(arg0); end
  def ensure_exists!; end
  def ensure_finished; end
  def ensure_no_cycle!(new_parent); end
  def ensure_started; end
  def eql?(other); end
  def exists?; end
  def finish!; end
  def in_span(name, kind: nil, labels: nil); end
  def initialize(trace, id, parent_span_id, parent, name, kind, start_time, end_time, labels); end
  def kind; end
  def kind=(arg0); end
  def labels; end
  def move_under(new_parent); end
  def name; end
  def name=(arg0); end
  def parent; end
  def parent_span_id; end
  def remove_child(child); end
  def same_children?(other); end
  def self.from_grpc(span_proto, trace); end
  def span_id; end
  def start!; end
  def start_time; end
  def start_time=(arg0); end
  def to_grpc(default_parent_id = nil); end
  def trace; end
  def trace_context; end
  def trace_id; end
end
class Google::Cloud::Trace::SpanKind
  def initialize(name); end
  def self.get(name); end
  def to_s; end
  def to_sym; end
end
class Google::Cloud::Trace::TimeSampler
  def call(env); end
  def initialize(qps: nil, path_blacklist: nil); end
  def path_blacklisted?(env); end
  def self.default; end
end
class Google::Cloud::Trace::TraceRecord
  def ==(other); end
  def add_root(span); end
  def add_span_protos(span_protos, parent_span_ids); end
  def all_spans; end
  def create_span(name, span_id: nil, parent_span_id: nil, kind: nil, start_time: nil, end_time: nil, labels: nil); end
  def eql?(other); end
  def in_span(name, kind: nil, labels: nil); end
  def initialize(project_id, trace_context = nil, span_id_generator: nil); end
  def internal_create_span(parent, span_id, parent_span_id, name, kind, start_time, end_time, labels); end
  def project; end
  def project_id; end
  def remove_root(span); end
  def remove_span(span); end
  def root_spans; end
  def self.find_root_span_ids(span_protos); end
  def self.from_grpc(trace_proto); end
  def to_grpc; end
  def trace_context; end
  def trace_id; end
  def unique_span_id; end
end
module Google::Cloud::Trace::Utils
  def self.grpc_to_time(grpc); end
  def self.time_to_grpc(time); end
end
module Google::Devtools
end
class Google::Cloud::Trace::Railtie < Rails::Railtie
  def self.consolidate_rails_config(config); end
  def self.init_default_config; end
  def self.init_middleware(app); end
  def self.merge_rails_config(rails_config); end
  def self.valid_credentials?(project_id, credentials); end
end
